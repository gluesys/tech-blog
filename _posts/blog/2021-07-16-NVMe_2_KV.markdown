---
layout:     post
title:      "NVMe 2.0 새로운 기능 - KV"
date:       2021-07-16
author:     김 성은(plumno1@gluesys.com)
categories: blog
tags:       [NVMe, NVMe 2.0, Key, Value, 키, 값, 키-값]
cover:      "/assets/Flash_memory_NVMe.jpg"
main:       "/assets/Flash_memory_NVMe.jpg"
---

안녕하세요! NVMe 관련 포스트를 추운 겨울에 썼던 것 같은데 벌써 뜨거운 여름이 되었네요. 꽤 긴 시간이 지난 만큼 그사이에 NVMe 2.0이 출시됐습니다! 그런 만큼 이번 포스트는 NVMe 2.0에서 새로 추가된 새로운 기능, 그중에서도 키-값 명령어(키-값 명령어)를 메인으로 다루어 보도록 하겠습니다.

&nbsp;

## 키-값 명령어 (Key-Value Command Set)

&nbsp;

### 키-값 데이터베이스(Key-Value Database)

키-값 명령어를 사용하는 SSD에 대해 알아보기 전에 먼저 키-값 데이터베이스에 관해 설명하겠습니다.  

![Alt text](/assets/hash.png)
<center>&#60; 연관 배열 &#62;</center>

키-값 데이터베이스는 연관 배열(Hash), 딕셔너리(Dictionary)와 같은 자료구조처럼 어떤 `키`를 사용하여 데이터베이스에 저장된 `값`을 찾아내는 방식의 데이터베이스입니다. 이때 `키`는 테이블별로 고유한 값을 지니고 있습니다. 예전에는 관계형 데이터베이스에 밀려 잘 쓰이지 않았다고 합니다. 하지만 정형 데이터밖에 넣을 수 없는 관계형 데이터베이스보다 비정형 데이터를 저장할 수 있는 특징 덕분에 근래에는 많이 사용되고 있다고 합니다.
&nbsp;

### 배경

키-값 명령어들이 새로 나오게 된 배경에는 위에서 잠깐 언급 드렸지만 최근 정형 데이터보다 비정형 데이터를 많이 저장하게 되었다는 것에 있습니다. 기존의 블록 저장 장치를 사용하는 경우, `키`와 논리 블록 주소(Logical Block Address)를 변환하는 별도의 소프트웨어가 필요하게 되는데, 그러면 만들어져 있는 키-값 데이터베이스 소프트웨어를 사용하지 않고 새로운 명령어까지 만든 이유는 무엇일까요? 그 이유는 이제 SSD 하드웨어 자체가 키-값 데이터베이스로 사용될 수 있기 때문입니다.  
이런 놀라운 기술을 만들 수 있었던 그 배경에는 이름 공간(Namespace)이 있었다고 합니다. NVMe 2.0에서 새로 출시된 기능인 `Namespace Types`에 대한 기능으로 각 네임스페이스의 특수한 접근 방법을 설정할 수 있게 되었습니다. 이것으로 인하여 각각의 이름 공간을 하나의 테이블처럼 사용할 수 있게 되었습니다.

&nbsp;

### 기능

이번에는 어떤 명령어들이 있는지 알아보겠습니다.

* Store command - 저장
  저장 명령어는 SSD에 주어진 `키`와 `값`으로 데이터를 저장하는 명령어입니다.  
  데이터베이스에서 트랜잭션처럼 원자성(atomictiy)을 띄고 있습니다.  
  새로 저장되는 데이터(`값`)를 압축(compress)/비압축(raw) 설정, 덮어쓰기(수정) 금지, 해당 `키`로는 `값`을 저장하지 않도록 생성 금지 명령 등이 가능합니다.  

* Retrieve command - 검색
  검색 명령어는 주어진 `키`로 `값`을 찾아주는 명령어입니다.  
  압축된 `값`을 압축 해제하여 검색, 비압축 검색이 가능합니다.  
  검색된 `값`의 길이(byte 단위)도 검색 결과로 볼 수 있습니다.  

* Exist command - 존재
  검색과는 다르게 정말 주어진 `키`가 존재하는지만 검색합니다.  
  만약 주어진 `키`가 존재한다면 `0x00`을 반환합니다.  
  반대로 찾지 못했다면 입력했던 `키`를 다시 반환합니다.  

* List command - 리스트
  주어진 이름 공간에 존재하는 모든 `키`들을 보여줍니다.  
  이 명령어로 나타난 `키`들은 정렬되어있지 않습니다.  

* Delete command - 삭제
  주어진 `키`와 그 `키`에 연관된 `값`을 삭제하는 명령입니다.  
  이 명령어도 원자성을 띄어 100% 완료되지 않으면 실행되지 않습니다.  

여기서 주의할 점은 `키`는 최대 `16 bytes`에서 `1 byte` 단위로 최소`1 byte` 길이를 가지는 가변적인 값입니다. 또한 `키`는 길이가 다르면 서로 다른 `키`로 인식됩니다. 예를 들어 16진수 `0x55`와 `0x0055`는 서로 다른 `키`로 인식됩니다. `값`은 최대 `4GB`의 크기를 가질 수 있으며 길이가 `0`일 수도 있습니다. 즉 `키`만 있고 `값`은 아무것도 없는 데이터도 저장할 수 있습니다.  
위 명령어들은 전부 이번 NVMe 2.0에서 출시된 NVMe 키-값 명령어 1.0 버전에서 명시된 필수 명령어들입니다. 이렇게 보니 충분히 하드웨어만으로도 데이터베이스를 만들 수 있을 것 같다는 생각이 듭니다.  

&nbsp;

### 장점

![Alt text](/assets/KV_Arch.png)
<center>&#60; Key-Value 구조 &#62;</center>

&nbsp;

키-값 명령어가 적용된 SSD로 데이터베이스를 구성 시 장점은 크게 2가지가 있습니다.
  
1. 기존 블록 저장 장치의 논리 블록 주소(LBA, Logical Block Address)를 `키`로 변환하는 과정이 필요 없다.
2. 프로비저닝 오버헤드가 사라짐
  
먼저 1번은 키-값 명령어를 사용하는 SSD는 위에서 언급했듯이 특수한 설정의 네임스페이스를 사용하여 데이터를 찾을 때 논리 블록의 주소로 찾는 것이 아니라 `키`가 데이터의 주소가 되기 때문에 다른 특별한 변환 작업을 수행할 필요가 없습니다. 따라서 그만큼의 성능 향상을 기대할 수 있습니다. 2번도 사실 1번과 관련이 있습니다. 논리 주소를 사용하지 않기 때문에 물리 주소와 논리 주소를 매핑해둘 필요가 없고 사용 가능한 주소의 범위는 SSD의 물리적인 용량으로 결정되는 것이 아니라 사용 가능한 총 `키`의 개수로 결정되기 때문입니다. 이처럼 키-값 명령어를 사용하는 SSD는 키-값 데이터베이스로 사용했을 때 일반 SSD보다 더 큰 용량과 빠른 성능을 보이는 강점이 있습니다.

&nbsp;

### Key-Value vs Object Storage

비정형 데이터를 저장하는 데에 있어 둘이 비슷한 공통점을 가지고 있긴 하지만 그 외에는 전혀 다른 장치라고 할 수 있습니다. 먼저 키-값 저장장치는 블록 저장장치가 아니라는 것 입니다. 앞서 말씀드렸듯이 가변 길이의 `키`를 주소로 사용하여 데이터를 저장하는 방식을 사용합니다. 반면에 오브젝트 스토리지는 블록 저장장치에 고정된 길이의 오브젝트 구분자를 사용하여 저장합니다. 또 `키`와 `값`, 오브젝트와 오브젝트 구분자를 각각 매핑하는 주체도 Key-Value에서는 스토리지(하드웨어) 그 자체가 `키`와 `값`을 서로 매핑하지만 오브젝트 스토리지는 프로토콜(소프트웨어)이 오브젝트 구분자와 오브젝트를 매핑하는 주체가 됩니다.  
  
그런데 Ceph에서 키-값 저장장치를 오브젝트 스토리지로 사용할 수 있도록 오픈소스 소프트웨어를 만들었습니다. 이제 오브젝트 스토리지는 블록 저장 장치만을 사용한다는 말은 틀린 말이 되어버렸네요.

&nbsp;

이렇게 NVMe 2.0에서 새롭게 출시된 기능 중 하나인 키-값 명령어에 대해 알아보았습니다. 하드웨어 자체를 데이터베이스로 사용하도록 만든다는 자체가 신기하게 다가와서 공부하면서도 재미있었던 것 같네요! 다음엔 어떤 신기한 기술들이 나올지 생각해보면서 이번 포스팅은 여기서 마치도록 하겠습니다~

[참고]

KVCeph: 
 * https://github.com/OpenMPDK/KVCeph
